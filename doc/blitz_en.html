<html>
<head>
<link href="bp.css" media="screen" rel="stylesheet" type="text/css" />
<meta name="description" content="Blitz templates, fast and powerfull PHP template engine for very big internet projects" /> 
<title>Blitz templates, fast and powerfull PHP template engine for very big internet projects</title>
<!--[if lt IE 8]><link rel="stylesheet" href="bp-ie.css" type="text/css" media="screen, projection"><![endif]-->
</head>
<body>

<div class="container">
<h1>Blitz templates, template engine extension for PHP</h1>
<div class="span-24"><em>fast and powerfull template engine for very big internet projects</em></div>
<div class="span-12"><p class="quiet">Alexey A. Rybak (c) 2005 - 2011</p></div>

<div class="span-18">
<h2>Quick Links</h2>
Development version: <a href="http://alexeyrybak.com/blitz/blitz-0.7.1.10-devel.tar.gz">blitz-0.7.1.10-devel.tar.gz</a>,  <a href="http://alexeyrybak.com/blitz/blitz-0.7.1.8-devel-win32.zip">0.7.1.8: WIN32 builds (PHP 5.3.*, both TS/NTS, VC6)</a><br>
Stable version: </b><a href="http://alexeyrybak.com/blitz/blitz-0.6.10.tar.gz">blitz-0.6.10.tar.gz</a>, <a href="http://alexeyrybak.com/blitz/blitz-0.6.10-php-5.2.12-win32.zip">0.6.10: WIN32 build (PHP5.2)</a><br>
Browse: <a href="http://alexeyrybak.com/blitz/all-releases/">all sources</a>, <a href="http://alexeyrybak.com/blitz/win32-binaries/">all win32 binaries</a><br>
Docs/Translations:
    <a href="http://alexeyrybak.com/blitz/blitz_en_old.html">english (old)</a>, 
    <a href="http://alexeyrybak.com/blitz/quick_geek.html">quick geek</a>,
    <a href="http://alexeyrybak.com/blitz/blitz_ru.html">russian (old)</a>,
    <a href="http://igaom.cn/blitz/Blitz_template.html">chinese (old)</a><br>
<a href="http://alexeyrybak.com/blitz/bt/">Bug Tracker</a><br>
User list: <i>blitz-php at googlegroups d0t c0m</i><br>
Developer's contact: <i>alexey d0t rybak at gmail d0t c0m</i><br>

<br>

<h2>Recent Blitz news</h2>
<li>blitz-0.7.1.10-devel released: minor fixes (<a href="http://alexeyrybak.com/blitz/blitz-0.7.1.10-devel.tar.gz">source</a>)
<li>blitz-0.7.1.9-devel released: minor fixes (<a href="http://alexeyrybak.com/blitz/blitz-0.7.1.9-devel.tar.gz">source</a>)
<li>Win32 builds for blitz-0.7.1.8-devel released (<a href="http://alexeyrybak.com/blitz/blitz-0.7.1.8-devel-win32.zip">binaries</a>)

<br><br>

</div>

<div class="span-6 last">
<img src="http://alexeyrybak.com/blitz/spaghetti.jpg">
</div>

<div class="span-24">
<h2>Developers guide</h2>
<div class="notice">
<h3>Table of contents</h3>
<li><a href="#quick-geek">0. Quick Geek Tutorial</a>
<li><a href="#intro">1. Introduction</a>
<li><a href="#install">2. Installation</a>
<li><a href="#conf">3. Configuration</a>
<li><a href="#basics">4. Basics: variables, contexts and methods</a>
    <ul>
        <li><a href="#basics-variables">4.1. Variables</a>
        <li><a href="#basics-contexts">4.2. Contexts</a>
        <li><a href="#basics-scope">4.3. Variable scope and contexts</a>
        <li><a href="#basics-includes">4.4. Includes</a>
        <li><a href="#basics-debugging">4.5. Debugging</a>
        <li><a href="#basics-fetch">4.6. Fetch</a>
        <li><a href="#basics-other">4.7. Other methods</a>
    </ul>
<li><a href="#callbacks">5. Callbacks and plugins</a>
<li><a href="#performance">6. Performance notes</a>
    <ul>
        <li><a href="#performance-benchmarks">6.1. Benchmarks</a>
        <li><a href="#performance-way">6.2. Slowdowns</a>
    </ul>
<li><a href="#api-template">7. Template API</a>
<li><a href="#api-view">8. View API</a>
</div>

<a name="quick-geek"></a>
<h2>0. Quick geek tutorial</h2>

<a name="intro"></a>
<p>If you are experienced developer who just needs to start working with Blitz very quickly - read this <a href="http://alexeyrybak.com/blitz/quick_geek.html">"Quick Geek Tutorial"</a>. It's quite old though - please refer to the <a href="#api-template">Template</a> or <a href="#api-view">View</a> API for new methods and features.

<h2>1. Introduction</h2>

<p>The most probably question you ask, viewing this document for the first time is: "What? Yet another template engine? What for?". Here comes a very short explanation. 

<br><br>Blitz is a templating engine with two main features:
<ul>
<li><em>Fast</em>. Blitz is written in C and built as PHP-extension which makes it one of the fastest template engines (you may see the <a href="#performance-benchmarks">benchmarks section</a> below)
<li><em>Clear</em>. Blitz has quite simple and clear syntax and makes developer to build compact and easy-to-read-and-support code even for applications with very complex presentation logic
</ul>

<br>These are my own development values which were formed through my own experience with large-scale internet projects.
Note, this all comes mostly from "management", not "programming", and has influence on large projects particularly. Let me explain this all briefly.

<br><br>
Is "fast" important? Talking about the speed I'm sure 99,9% of projects are not CPU-bound. But large projects are. Most of top projects have thousands frontends serving billions requests per day (top of the top has even much more). Performance management is a field of special importance here. Usually storage/application services are tuned as much as possible and CPU usage on frontend boxes is, well, not bottleneck, but one of very important degrees of freedom. Crooked solutions which scale badly will significantly increase your total cost. From my personal experience presentation code may eat up to 30-50%% CPU for the dynamic page generation in a "good" project and up to 100% in "bad". Think of that: your frontend CPU spends most of the time just building result HTML! It is very important to decrease this value. With Blitz you won't spend much CPU on presentation level (see benchmark results below).

<br><br>
Is "clear" important? Talking about the simplicity of presentation code I'm absolutely sure 99,9% of projects can be written in plain PHP and happily supported through years. Plain PHP is probably the best solution from the performance point of view as well. There's one problem though. Supporting the mess of PHP and HTML in a big project is usually just a nightmare. Large projects usually have large codebase and a lot of problems appear while trying to manage PHP+HTML spaghetti in presentation code. This happens because modern, personalized applications have very complex presentation logic and this all tend to change intensively. This logic should be written, owned and supported by developer (I also suppose here that HTML/CSS competence is much different from programming so developers better don't touch this stuff at all - and vice versa). But when you have PHP code together with HTML and Javascript in templates - the ownership and the responsibility is too fuzzy. That's why I always wanted HTML/JS guys to keep their hands off the presentation logic. I do know what happens otherwise when this part of application is "shared". That's why I wanted to maximally separate HTML and view logic. I wanted to see the code, with no HTML/Smarty/PHP/Whatever spaghetti mess. I wanted developers to work with the code, with no HTML or JS around. Well, that is a some kind of management philosophy. You just feel this "right" - or not :))) 

<br><br>
I started this project in 2005 as a replacement of php_templates by Maxim Poltarak, a very fast PHP template engine which was popular in ealy 200x mostly among developers in former USSR countries. This engine was unjustly rejected by PHP team long time ago (they didn't let it into PECL for absolutely childish reasons) so the project was frozen and got no further developments.  I took most of "design" concepts from php_templates and thank Maxim for his great project. 

<br><br><a name="install"></a>

<h2>2. Installation</h2>

Blitz is a PHP extension distributed in source code (Win32 users can download compiled DLL's).

<br><br>
To extract the code and build the extension just follow these simple steps:

<pre>
tar zxvf blitz-0.6.10.tar.gz
cd blitz-0.6.10
phpize
./configure
make install
</pre>

To test blitz run the test script run-tests.sh. <i>You need to edit this file to change the path to the standart PHP test routine run-tests which comes with PHP</i>. Running the tests you will get something like this:

<pre>
fisher@fisher:~/prj/blitz> ./run-tests.sh
=====================================================================
PHP         : /usr/local/bin/php5
PHP_SAPI    : cli
PHP_VERSION : 5.3.2-dev
ZEND_VERSION: 2.3.0
PHP_OS      : Linux - Linux fisher 2.6.11.4-20a-smp #1 SMP Wed Mar 23 21:52:37 UTC 2005 i686
INI actual  : /local/php_5_3_fpm/lib/php-cli.ini
More .INIs  :
CWD         : /home/fisher/prj/blitz
Extra dirs  :
VALGRIND    : Not used
=====================================================================
Running selected tests.
PASS block [tests/block.phpt]
PASS Bug #83 (double free on include()) [tests/bug83.phpt]
PASS clean [tests/clean.phpt]
PASS comments [tests/comments.phpt]
PASS contexts [tests/context.phpt]
PASS date output wrapper [tests/date.phpt]
PASS double Blitz object initialization [tests/double_init.phpt]
PASS report duplicate contexts [tests/duplicates_001.phpt]
PASS broken templates 001 [tests/error_001.phpt]
PASS broken templates 002 [tests/error_002.phpt]
PASS errors and warnings: syntax [tests/errors1.phpt]
PASS errors and warnings: execution [tests/errors2.phpt]
PASS escape output wrapper [tests/escape.phpt]
PASS fetch#1 [tests/fetch1.phpt]
PASS fetch#2 [tests/fetch2.phpt]
PASS fetch#3 [tests/fetch3.phpt]
PASS get context [tests/get_context.phpt]
PASS has context [tests/has_context.phpt]
PASS if/unless predefined methods [tests/if.phpt]
PASS conditional contexts (multi-line conditions): if/end and unless/end [tests/if_context.phpt]
PASS controller include method [tests/include-method.phpt]
PASS predefined methods: include [tests/include.phpt]
PASS include with context iteration [tests/include_ctx.phpt]
PASS multiple include cache test [tests/include_multi.phpt]
PASS ini-values settings test [tests/ini.phpt]
PASS nonexistant path iteration [tests/iterate_nonexistant.phpt]
PASS user-defined methods [tests/method.phpt]
PASS method call from inner include [tests/mfi.phpt]
PASS mix #1 [tests/mix1.phpt]
PASS mix #2 [tests/mix2.phpt]
PASS mix #3 [tests/mix3.phpt]
PASS mix #4 [tests/mix4.phpt]
PASS mix #5 [tests/mix5.phpt]
PASS mix #6 [tests/mix6.phpt]
PASS numerical and non-numerical keys in the iteration set [tests/non_num_iter.phpt]
PASS parse with iteration set [tests/parse_with_iterations.phpt]
PASS relative path (blitz.path) [tests/path.phpt]
PASS partial php_templates syntax compability [tests/phpt_compability.phpt]
PASS plugins [tests/plugins.phpt]
PASS predefined loop variables: $_total, $_num, $_even, $_odd, $_first, $_last [tests/predefined.phpt]
PASS returning non-strings from user methods [tests/return_non_string.phpt]
PASS scope lookup test #1 [tests/scope.phpt]
PASS scope lookup test #2 [tests/scope2.phpt]
PASS set and get [tests/set_and_get.phpt]
PASS mixed set [tests/set_mixed.phpt]
PASS remove empty spaces around context tags [tests/spaces.phpt]
PASS variables [tests/var.phpt]
PASS unprefixed variables syntax [tests/var_no_prefix.phpt]
PASS {{ $hash.sub.key }} syntax [tests/var_path.phpt]
PASS iterate after wrong previous iterations [tests/wrong_iterations.phpt]
=====================================================================
Number of tests :   50                50
Tests skipped   :    0 (  0.0%) --------
Tests warned    :    0 (  0.0%) (  0.0%)
Tests failed    :    0 (  0.0%) (  0.0%)
Expected fail   :    0 (  0.0%) (  0.0%)
Tests passed    :   50 (100.0%) (100.0%)
---------------------------------------------------------------------
Time taken      :    1 seconds
=====================================================================
</pre>

If Blitz was build as shared module you will probably need to edit your php.ini and include Blitz in extension list: 
<pre>
extension=blitz.so 
</pre>

<br><a name="conf"></a>

<h2>3. Configuration</h2>

This list is based on 0.7.* versions. See the difference in old 0.6.* below.
<br><br>

<li><em>blitz.var_prefix</em> - variable prefix, default is "$" 
<li><em>blitz.tag_open</em> - open tag, default is "{{" (double brackets are used not to confuse with single CSS brackets)
<li><em>blitz.tag_close</em> - close tag, default is "}}"
<li><em>blitz.tag_open_alt</em> - alternative open tag, default is "&lt;!-- " (Note: 5 symbols with space in the end)
<li><em>blitz.tag_close_alt</em> - alternative close tag, default is " --&gt;" (Note: 4 symbols with space in the beginning)
<li><em>blitz.comment_open</em> - open comments tag, default is "/*"
<li><em>blitz.comment_close</em> - close comment tag, default is "*/"
<li><em>blitz.enable_alternative_tags</em> - use 0/1 to disable/enable alternative tags, "1" by default
<li><em>blitz.enable_comments</em> - use 1/0 to enable/disable comments, "0" by default
<li><em>blitz.path</em> - prefix filenames when they don't start with '/' (UNIX/Linux) or '[A-Z]:\' (Windows), default is ""
<li><em>blitz.disable_include</em> - disable includes for true paranoid, "0" by default
<li><em>blitz.remove_spaces_around_context_tags</em> - remove annoying spaces and linebreaks around context tags, "1" by default
<li><em>blitz.warn_context_duplicates</em> - warn if there are contexts with the same name, "0" by default
<li><em>blitz.check_recursion</em> - check recursion, 0/1, "1" by default
<li><em>blitz.charset</em> - charset for "escape" method (used in internal php_escape_html_entities call), "" by default
<li><em>blitz.scope_lookup_limit</em> - the depth of "upper stack" lookups when variable is not found in current context scope, default is "0"

<br><br> Please note some differences with old 0.6.* versions:
<br><br>

<li><em>blitz.tag_open_alt</em> and <em>blitz.tag_close_alt </em>were called <em>blitz.phpt_ctx_left</em> and <em>blitz.phpt_ctx_right</em> correspondingly
<li><em>blitz.remove_spaces_around_context_tags</em> was switched off by default
<li><em>blitz.comment_open</em>, <em>blitz.comment_close</em>, <em>blitz.enable_alternative_tags</em>, <em>blitz.enable_comments</em>, <em>blitz.charset</em>, <em>blitz.scope_lookup_limit</em> were added in 0.7.* only.

<br><br><a name="basics"></a>

<h2>4. Basics: variables, contexts, methods</h2>

<a name="basics-variables"></a>
<h3>4.1. Variables</h3>

The "view" component of your application will be built by <b>templates</b> and <b>views</b>("views" are also referred as <b>template controllers</b>. Let's start with the following example: 

<div class=grey_box>
<pre>
$View = new Blitz();
$View->load('Where is the {{ $what }}, Lebowski?');
$View->display(array('what' => 'money'));
</pre>
</div>

This code produces the string 'Where is the money, Lebowski?'. Here we have an anonymous <b>template</b> loaded
as string and a <b>template controller</b> $View. 

<br><br>
Normally you'll load templates from files: 

<div class=grey_box>
<pre>
$View = new Blitz('some.tpl');
</pre>
</div>

But load() method is very usefull to write tests quickly - no need to create separate template file.

<br><br>Template is an HTML file with some very simple syntax. No complex code mixed with HTML.
Controller is a template logic master, an instance of Blitz
class which operates template from opening to the final result.
Template controller is not your application controller which
stands for "C" in MVC. No HTML code inside template controller is needed.

<br><br><a name="basics-contexts"></a>

<h3>4.2. Contexts</h3>

The reason why Blitz objects are called <b>"template controllers"</b> is simple. From the very early days template language in Blitz was designed to be as simple ("non-programming") as possible. For example, there is still no "for" or "foreach" statement in Blitz. 
This surely doesn't mean you can't do any looping :) But you have to loop from your PHP-code, this is called "passive" templates (in Blitz you can do a lot of "active" templating as well - conditions, callbacks, plugins - but loops like "foreach", complex expressions, all these "programming" statements are still under the law). 

<br><br>
To make a loop you need to use blocks in your templates. Block, or context, is a part of template marked by {{ BEGIN }} and {{ END }} tags. Blocks can be populated on demand but hidden by default:

<div class=grey_box>
<pre>
$View = new Blitz();
$View->load('hello {{ BEGIN block }} {{ $name }} {{ END }}');
$T->display(array('block' => array('name' => 'Dude')));
</pre>
</div>

This template produces just a "hello " string by default and the block is hidden. When you set 'block' key into template variables Blitz executes the block and the result is "hello  Dude ". The value of 'block' is a hash. Blitz treats this hash as parameters. If you put an array of hashes - Blitz executes the block for every array element. Blocks are also referred as contexts. An execution of block is called "iteration". 

<br><br>
To make the code simpler to read one can put a block name after END statement: {{ END block }}.

<br><br>
There is a special 'block' method that will perobably make your code a bit easier to read:

<div class=grey_box>
<pre>
$View = new Blitz();
$View->load('hello {{ BEGIN block }} {{ $name }} {{ END block }}');
$View->block('/block', array('name' => 'Dude'));
$View->display();
</pre>
</div>

To make lists you just need to iterate blocks several times:
<div class=grey_box>
<pre>
foreach (array('Dude', 'Donny', 'Sobchak') as $i_name) {
    $T->block('/block', array('name' => $i_name);
}
</pre>
</div>

Being placed instead of a single block call in the previous example this will
output

<div class=grey_box>
<pre>
"Hello  Dude  Donny  Sobchak "
</pre>
</div>

Note the number of spaces between names. 
This is not a mistake, everything is absolutely correct: for "Dude" first space
comes from 'hello_' and second space comes from '_{{ $name'; 
"Donny" has two spaces from previous iteration ('$name }}_' = 'Dude_') and
an additional space from '_{{ $name'; and finally "Sobchak" has two spaces before
for the same reasons as "Donny" and one space after becase of '$name }}_'.

<br><br>
Every block is identified by it's path like "/block". A block placed inside another has path /parent/child. Even things like '../../some/path' work.

<br><br>
As you could see there can be two ways of "controlling" template blocks. The first is to use "block" methods (there are also additional methods to set up active context, to iterate the current context and so on). The second is just to set up complex data structures with keys named equal to block names. In previous examples we set up a hash for 'block'. To produce a list you just need this hash to be an array of hashes:

<div class=grey_box>
<pre>
$View = new Blitz();
$View->load('hello {{ BEGIN block }} {{ $name }} {{ END }}');
$T->display(
    array('block' => array(
        array('name' => 'Dude'),
        array('name' => 'Donny'),
        array('name' => 'Sobchak'),
    ))
);
</pre>
</div>

Let's take a break and think what we have here. Single block iteraton was just like "if".
Multiple block iteration was like "foreach". This is all quite tricky for the first time,
but if you have "math" mind - this all becomes clear and simple very soon.
Note that you don't need to add any language constructs into the template.
What you do - just play with template controller, iterating template blocks. 

<br><br>Honestly, using blocks as "if" substitution is crazy :) See what you have to do if you just need a simple comma separated list in the previous example. At first you have to add a special separator block:
<div class=grey_box>
<pre>
hello {{ BEGIN block }}{{ BEGIN comma }},{{ END }} {{ $name }} {{ END }}
</pre>
</div>

then you have to add this code to iterate this when needed:

<div class=grey_box>
<pre>
$need_comma = FALSE;
foreach (array('Dude', 'Sobchak', 'Donny') as $i_name) {
   if ($need_comma) {
       $T->block('/block/comma');
   } else 
       $need_comma = TRUE;
   }
   $T->block('/block', array('name' => $i_name);
}
</pre>
</div>

When your logic is simple you can use a very basic "if" statement to make things much easier:

<div class=grey_box>
<pre>
hello {{ BEGIN block }}{{ if($_first,'',',') }} {{ $name }} {{ END }}.
</pre>
</div>

And the code remains as simple as:

<div class=grey_box>
<pre>
foreach (array('Dude', 'Donny', 'Sobchak') as $i_name) {
    $T->block('/block', array('name' => $i_name);
}
</pre>
</div>

You can use any variable name instead of $_first but then you need 
to set this variable manually from controller. $_first is a predefined 
variable, equal to 1 when it's the first block iteration and 0 otherwise.
Other predefined loop variables are: $_last, $_total, $_num, $_even, $_odd.
Most of these variables have clear meaning, $_total is a number of context 
iterations and $_num is a current number starting with 1, $_even and $_odd 
are 1 or 0 depending on if the current iteration value is even or odd.

<br><br> Here we used a short form of "if" as a "method". You can use condition blocks as well:
<div class=grey_box>
<pre>
hello {{ BEGIN block }} {{ UNLESS $_first }}, {{ END }} {{ $name }} {{ END }}.
</pre>
</div>

The full version of IF/UNLESS block is a IF(UNLESS)/ELSEIF/.../ELSEIF/ELSE/END set. 
UNLESS means "if not" condition. Expressions are not currently supported,
but simple expression support is included into the development plan.

<br><br><a name="basics-scope"></a>

<h3>4.3. Variable scope and contexts</h3>

Let's finally take a complex list example

<div class=grey_box>
<pre>
$body = &lt;&lt;&lt;BODY
{{ BEGIN list }}
==================================================
list #{{ \$_num }}, x = {{ \$x }}
{{ UNLESS sublist }}
   empty
{{ ELSE }}
--------------------------------------------------
{{ BEGIN sublist }}
  row #{{ \$_num; }} v = {{ \$v }}, x = {{ \$x }}
{{ END }}
{{ END }}
{{ END }}
BODY;

$T = new Blitz();
$T->load($body);

$data = array(
    'list' => array(
        0 => array(
            'x' => 'first'
        ),
        1 => array(
            'x' => 'second',
            'sublist' => array(
                0 => array('v' => 'a'),
                1 => array('v' => 'b'),
            )
        )
    )
);

$T->display($data);
</pre>
</div>

This code will produce:

<div class=grey_box>
<pre>
==================================================
list #1, x = first
   empty
==================================================
list #2, x = second
--------------------------------------------------
  row #1 v = a, x =
  row #2 v = b, x =
</pre>
</div>

See that 'x' value is empty in a 'sublist' context. For the performance reasons Blitz checks only current iteration parameters and this hash doesn't have any 'x' key. To have variable inside block you have three options:
<li>pass it via params manually for every context iteration
<li>pass it as global once
<li>force Blitz to make "upper" lookups when parameter was not found

<br><br>Globals are set by setGlobals() method:

<div class=grey_box>
<pre>
// body remains the same
...

$T = new Blitz();
$T->load($body);

// data remains the same
... 

$T->setGlobals(array('x' => 'global x'));
$T->display($data);
</pre>
</div>

This code produces:
<div class=grey_box>
<pre>
==================================================
list #1, x = first
   empty
==================================================
list #2, x = second
--------------------------------------------------
  row #1 v = a, x = global x
  row #2 v = b, x = global x
</pre>
</div>

Now 'x' is not empty and filled with global value. But usually we need to pass variable from parent iteration to children. 
This is switched off by default but you can enable this by 'blitz.scope_lookup_limit' setting:

<div class=grey_box>
<pre>
ini_set('blitz.scope_lookup_limit', 1);
</pre>
</div>

This setting defines the depth of these lookups: 1 means that only one parent lookup
in parent params will be proceed when variable is not found in child params.
Adding this set before display we get:

<div class=grey_box>
<pre>
==================================================
list #1, x = first
   empty
==================================================
list #2, x = second
--------------------------------------------------
  row #1 v = a, x = second
  row #2 v = b, x = second
</pre>
</div>

These lookups were added in 0.7.5 version and are not supported in previous versions.Lookups are proceed only when variable can't be found. This means that if you have a lot of missing variables and your 'blitz.scope_lookup_limit' value is high - you will have a lot of useless hash lookups resulting in useless CPU usage. Be carefull playing with this setting.

<br><br><a name="basics-includes"></a>

<h3>4.4. Includes</h3>

In previous section you could see an example of so called "internal method" - if(). These are statements like function calls in the template code. Blitz has several internal methods like this - and one of them is include(). Just say: {{ inlcude("some.tpl") }} or {{ include($file) }} - that's it. Works same way as PHP itself. How does variable scope work with include? Right the same way as if the include statement was replaced by the content from the included file. Let's see the example. Included template represents the list of names:

<div class=grey_box><pre>
Cast: {{ BEGIN cast }}{{ UNLESS $_first }}, {{ END }}{{ $name }}{{ END }}
</pre></div>

The script sets iteration data structure for the blocks from the included template
<div class=grey_box><pre>

$T = new Blitz();
$T->load('{{ include("include_ctx.tpl") }}');

$data = array(
    array('name' => 'Jeff Bridges'),
    array('name' => 'John Goodman'),
    array('name' => 'Julianne Moore')
    array('name' => 'Steve Buscemi')
);

$T->set(array('cast' => $data));

$T->display();
</pre></div>

This result is:
<div class=grey_box><pre>
Cast: Jeff Bridges, John Goodman, Julianne Moore, Steve Buscemi
</pre></div>

Everything is very simple. There's one tricky thing with includes though. 
This affects cases when you iterate included blocks using block() or iterate() methods. 
In this case you provide context path and Blitz checks internal template structure 
if this path is correct. But Blitz checks parent template, and includes are processed on the execution stage.
This all happens for performance reasons. Include could be just put into block and not executed at
all. In the worstest case included file name could be passed throught parameters and Blitz just can't
know included block names anyway. So at the check stage Blitz can't see blocks from
included template and doesn't iterate anything. Unfortunately this happens silently with no warning. 
This gonna be redesigned - but we have this still. To fix this just use additional third parameter
in block() or iterate(), which means "just do what I say and don't check anything".
See the following example. We use the same template as in prevoius example:

<div class=grey_box><pre>
Cast: {{ BEGIN cast }}{{ UNLESS $_first }}, {{ END }}{{ $name }}{{ END }}
</pre></div>

But now we use block() method

<div class=grey_box><pre>

$T = new Blitz();
$T->load('{{ include("include_ctx.tpl") }}');

$list_names = array('Jeff Bridges', 'John Goodman', 'Julianne Moore', 'Steve Buscemi');
foreach ($list_names as $i_name) {
    $T->block('/cast', array('name' => $i_name), TRUE);
}

$T->display();
</pre></div>

With third parameter of block() we have the same result:

<div class=grey_box><pre>
Cast: Jeff Bridges, John Goodman, Julianne Moore, Steve Buscemi
</pre></div>

Without TRUE third parameter we'll have no iterations:

<div class=grey_box><pre>
Cast: 
</pre></div>

<br><a name="basics-debugging"></a>

<h3>4.5. Debugging</h3>

Internal representation of a template stage in Blitz is just a complex data structure
with key names equal to variable or block names. This data is saved in template internally
and can be dumped using method getIterations() when debugging. In the next example
we iterate blocks sequentially using block() method, set some additional data with set() method, 
get the iteration data with getIterations() method, clean all the iterations and display the
template using previously dumpled data: 
<a name="example-get-iterations"></a>
<div class=grey_box><pre>
$T = new Blitz();
$T->load('{{ include("test.tpl") }}');

$list_names = array('Jeff Bridges', 'John Goodman', 'Julianne Moore', 'Steve Buscemi');
foreach ($list_names as $i_name) {
    $T->block('/cast', array('name' => $i_name), TRUE);
}

$T->set(array('film' => 'The Big Lebowski'));
$data = $T->getIterations();

var_dump($data);

$T->clean();
var_dump($T->getIterations());

$T->display($data);
</pre></div>

The result is:

<div class=grey_box><pre>
array(1) {
  [0]=>
  array(2) {
    ["cast"]=>
    array(4) {
      [0]=>
      array(1) {
        ["name"]=>
        string(12) "Jeff Bridges"
      }
      [1]=>
      array(1) {
        ["name"]=>
        string(12) "John Goodman"
      }
      [2]=>
      array(1) {
        ["name"]=>
        string(14) "Julianne Moore"
      }
      [3]=>
      array(1) {
        ["name"]=>
        string(13) "Steve Buscemi"
      }
    }
    ["film"]=>
    string(16) "The Big Lebowski"
  }
}
array(0) {
}
The Big Lebowski cast: Jeff Bridges, John Goodman, Julianne Moore, Steve Buscemi
</pre></div>

<br>Sometimes you have correct iterations but your code doesn't work properly still. 
Use getStruct()/dumpStruct() methods to check if there is everything OK with your template. 
See <a href="#api-view">View API</a> for examples.

<br><br><a name="basics-fetch"></a>

<h3>4.6. Fetch </h3>
When working with large templates you oftenly want to get a part of template. This is done by fetch() method:

<div class=grey_box>
<pre>
$body =&lt;&lt;&lt;BODY
{{ BEGIN test }}
Hello, {{ $name }}!
{{ END }}
BODY;

$T = new Blitz();
$T->load($body);
echo $T->fetch('test', array('name' => 'world!'));

</pre>
</div>

This code will output the contents of executed 'test' block:

<div class=grey_box><pre>
Hello, world!
</pre></div>

Fetch can be used in template body as well. Usually it's just a trick, but this works:

<div class=grey_box>
<pre>
$body =&lt;&lt;&lt;BODY
{{ fetch('/test') }}
{{ BEGIN test }}Hello, world!{{ END }}
BODY;

$T = new Blitz();
$T->load($body);
$T->display();
</pre>
</div>

This code outputs "Hello, world!" as well.

<br><br><a name="basics-other"></a>
 
<h3>4.7. Other internal methods</h3>

Basic internal methods are: if(), include(), date() and escape(). Two first methods were mentioned above, 
and two last are new. Let's cover them briefly.

<br><br>
Method date(format, argument) used to format date/time values just from your template. 
It works as follows: when argument is integer, date() treats it as UNIX timestamp. 
Otherwise it's parsed with internal PHP function "php_parse_date" which recognize a lot of date formats. 
When ARG is omitted - the current time is used. Format string has the same conversion specifiers as 
PHP function "strftime".

<br><br>
Method escape(string) is equal to htmlspecialchars(string, ENT_COMPAT). You can use additional
second parameter to specify quoting style which is passed as string, named as the corresponding PHP constant:
escape(string, "ENT_QUOTES") or escape(string, "ENT_NOQUOTES") etc. Blitz supports all three quote styles:
"ENT_COMPAT", "ENT_QUOTES" and "ENT_NOQUOTES".

<br><br><a name="callbacks"></a>

<h2>5. Callbacks and plugins</h2>

Blitz supports callbacks like {{ Some::doSomething($params) }} or {{ doSomething($param) }}. 
With this you can add any function calls to your template. <br><br>

Basically you can:<br>
1) extend Blitz and use your custom template methods in the template code<br>
2) call any other PHP function like do($something) or Plugin::do($something)<br><br>

See the following example:<br><br>
<div class=grey_box>
<pre>
fisher@fisher:~/prj/blitz/tests&gt; cat calls.php
&lt;?

$body = &lt;&lt;&lt;BODY
   {{ php::date("Y/m/d H:i") }}
   self-call: {{ this::doSomething() }}
   php-call: {{ php::doSomething() }}
   this+php call: {{ doSomething() }}
   this+php call: {{ doSomething2() }}

BODY;

function doSomething() {
   return 'PHP :: did comething';
}

class View extends Blitz {
   function doSomething() {
       return 'THIS :: did something';
   }

   function __call($a, $b) {
       return '__call handler: '.var_export($a, true).', '.
            str_replace(array("\n","\r"), "", var_export($b, true));
   }
}

$T = new View();
$T-&gt;load($body);
$T-&gt;display();

?&gt;
fisher@fisher:~/prj/blitz/tests> php5 calls.php
   2010/04/02 23:57
   this-call: THIS :: did something
   php-call: PHP :: did comething
   this+php call: PHP :: did comething
   this+php call: __call handler: 'dosomething2', array ()
</pre>
</div>

To understand how this all works let's see how Blitz examines the call:<br>
<ul><li>When there is a namespace and a '::' before function, Blitz checks if the namespace is a "hint". "Hints" are reserved namespaces: {{ php::do($params) }}, or {{ this::do($params) }}
<ul><li>When namespace is a "hint" ("php" or "this"). 
Having {{ php::do($params) }} Blitz makes a static php-function call, having {{ this::do($param) }} do() method is called
through the current template object.
<li>When namespace is not a "hint", Blitz makes
a static PHP-call namespace::do($params). If this namespace and function exists - the function will be called.</ul>
<li>When there was just a function call with no namespace like {{ do($params) }} Blitz makes a static PHP-function call. 
If this function doesn't exist - Blitz calls this method through your template controller.</ul><br>

Now we can go back to the example:
<ul>
<li>{{ php::date("Y/m/d H:i") }} - is a PHP-function call
<li>{{ this::doSomething() }} - is a "hinted" doSomething() method call through the View object $T
<li>{{ php::doSomething() }} - is a "hinted" doSomething() function call from the current function scope
<li>{{ doSomething() }} - is a function call from the current function scope
<li>{{ doSomething2() }} - there's no doSomething2() function in the current scope and Blitz makes a method call through the View object $T. This call is handled by __call() because  doSomething2() method doesn't exist.
</ul>

<br><a name="performance"></a>
<h2>6. Performance notes</h2>
<a name="performance-benchmarks"></a>

<h3>6.1. Benchmarks </h3>

Unfortunately, I don't know any simple, universal and really correct method to analyse template engine performance. 
The only one right way to do this is to build your application using several template engines and measure the performance
under the real conditions. Should it be noted that nobody is going to do this? That's why we always deal with artificial
tests which results should be used very carefully. Nevertheless, results of one "synthetic" test are listed here.<br><br>

This test is much closer to real world conditions than most of tests you can find in the Internet (like "wow, we have printed this variable 200 times!!!11"). First we have a page of several non-trivial parts. The code is written using different template engines. This page is built by a webserver, and the performance is benchmarked using the standard apache ab utility. The page simulates a some pseudo portal main page and contains:
<ul>
<li> adverts (3 items) </li>
<li> news list (5 items, 5 vars each)</li>
<li> striped navigation (7 sections) </li>
<li> list of users online(~20 items) </li>
<li> vote with 3 possible answers </li>
<li> other variables (~10 items) </li>
</ul>

<br>
Tests include lot of different template engines. Leaders are:
<ul>
<li>PHP mess: PHP and HTML are messed in a single file. This method is used in the real big projects in very specific cases only, but included into the tests just because it is obviously the fastest one.</li>
<li>blitz: single template, every functional block has it's own context</li>
<li>PHP includes: PHP and HTML are messed but functionally different blocks(list elements) are separated and included from the main code.</li>
<li>php_templates: single template, every functional block has it's own context</li>
<li>smarty: single template, compiled, output cache is off</li> 
</ul>

<br><a name="bench"></a>The results of this test can be found below.<br>
<br><img src="lebowski-bench-big.gif"><br>

Software versions and settings were:<br>
<pre>
PHP 4.3.10, ZPS 4.0.2
Sigma 1.1.5 (cache on)
Smarty 2.6.15 (tpl-compile on, output-cache off)
Blitz 0.4.3
FastTemplate 1.1.0
XTemplate 0.3.0
php_templates 1.7
cTemplate 0.8 (ctemplate 0.4, nothreads)
</pre>

<br>These measurements were made quite long time ago (PHP 4.3.* with Zend Performance Suite, and old versions of template engines).
Now we need to make the same test with modern PHP 5.3.* with APC. If you can help with this - please drop me an email. 
I still need benchmark tests for some popular systems like CTPP, ClearSilver, Twig, Lapa, Quicky, Macro/WACT or possibly many others. 
If you just send me how to implement the test with these systems - I'll test it and add the results here.
The benchmark code is available to <a href = "http://alexeyrybak.com/blitz/lebowski_bench.tar.gz"> download</a> and one can add benchmark code for any other template engine. 

<br><br>Results above should be interpreted in a very generalized way. Native PHP-code is obviuosly the fastest. What is more important, "native" here means written by hands, not "compiled". If you ever looked into a "compiled" template you probably know that its code has a lot of nested constructions, quite hard to execute (with a lot of unnecessary hash lookups, for instance), much more complex than written by right hands code ;) One more important thing is obvious as well: the less files you have the most effective your code is, and Blitz context methods are faster than include. I used single file methods for both php_templates and Smarty to squeeze maximum from them, so i suppose Blitz to be visibly faster.

<br><br>The difference between Blitz and commonly used "php includes" method is not very big. In real world application any difference will be likely hidden against the background of other code especially database requests et cetera. Thus both of the methods could be considered as practically equal. You can notice that most of the tests were made using an accelerator from ZPS. Using accelerator is very significant for PHP code - but you possibly can obtain different results using other products like APC/XCache/eAccelerator/whatever. In general, one should not to rely on the quoted results entirely. Make tests, play with real projects and choose solutions, which give a profit under your own particular conditions.

<br><br><a name="performance-way"></a>
<h3>6.2. Slowdowns</h3>

Blitz performance receipes are the same as for any web-applications with CPU bottleneck. Following things in Blitz may slow down your application:<br>

<ul>
<li>lot of includes (all the data will seat in VFS cache almost immediately, but includes always add some kernel syscalls and need CPU to parse/initialize objects).
<li>lot of hash lookups to resolve path-variables $obj.smth.blabla, performance downgrades proportionally to the product number_of_variables*average_path_length
<li>lot of hash lookups back through the scope stack
<li>lot of block()/iterate() calls instead of preparing set data and just calling $View->display($data)
<li>lot of non-built-in Blitz methods in templates (user defined callbacks or PHP-functions)
</ul>

<br><a name="api-template"></a>
<h2>7. Template API</h2>

<div class="notice">
<ul>
<li><a href="#api-template-if-else">[IF|UNLESS]/ELSEIF/ELSE statments</a>
<li><a href="#api-template-if-method">if(predicate, output_true [, output_false])</a>
<li><a href="#api-template-include">include(filename)</a>
<li><a href="#api-template-escape">escape(html [, "ENT_QUOTES"|"ENT_NOQUOTES"|"ENT_COMPAT")</a>
<li><a href="#api-template-date">date(format [, arg)</a>
</ul>
</div>


<a name="api-template-if-else"></a>
<h3>7.1 [IF|UNLESS]/ELSEIF/ELSE statments</h3>

It's a simple as {{ IF $a }} if-a {{ ELSEIF $b }} else-if-b {{ ELSE }}
default {{ END }}. {{ UNLESS $a }} will work instead of {{ IF $a }} as well, but no "ELSEUNLESS" is provided.
Expressions are not supported yet. Will be supported. Someday ;)

<br><br>The most usual example of these statements is a list which can be empty:

<div class=grey_box><pre>
{{ IF $list }}
    some html code before the list
    {{ BEGIN list }} {{ $data }} {{ END list }}
    some html code after the list
{{ ELSE }}
    some html code for empty list
{{ END if-list }}
</pre></div>

<br>

<a name="api-template-if-method"></a>
<h3>7.2 if(predicate, output_true [, output_false])</h3>

If() method is a short version for predicates. If() outputs arguments according to the first argument:

<div class=grey_box><pre>
$T = new Blitz();
$T->load("{{ $num }}. {{ $name }} {{ if($rip,'[R.I.P.]') }}");

$character = array(
    array(1, 'The Dude',            0),
    array(2, 'Walter Sobchak',      0),
    array(3, 'Donny',               1), // RIP, Donny
    array(4, 'Maude Lebowski',      0),
    array(5, 'The Big Lebowski',    0),
    array(6, 'Brandt',              0),
    array(7, 'Jesus Quintana',      0),
);

foreach ($character as $i => $i_data) {
   echo $T->parse(
       array(
           'num'    => $i_data[0],
           'name'   => $i_data[1],
           'rip'    => $i_data[2]
       )
   );
}
</pre></div>

This code outputs:<br>

<div class=grey_box><pre>
1. The Dude
2. Walter Sobchak
3. Donny [R.I.P.]
4. Maude Lebowski
5. The Big Lebowski
6. Brandt
7. Jesus Quintana
</pre></div>

<br>

<a name="api-template-include"></a>
<h3>7.3 include(filename)</h3>
Include() method includes external template.<br><br>

1.tpl:
<div class=grey_box><pre>
{{ $what }}
</pre></div>

php code:
<div class=grey_box><pre>
$T = new Blitz();
$T->load("Where is the {{ include('1.tpl') }}, Lebowski?\n");
$T->display(array('what' => 'money'));
</pre></div>

output:
<div class=grey_box><pre>
Where's the money, Lebowski?
</pre></div>

<br>

<a name="api-template-escape"></a>
<h3>7.4 escape(html [, "ENT_QUOTES"|"ENT_NOQUOTES"|"ENT_COMPAT")</h3>
Escape() is a very simple html output wrapper, works like htmlspecialchars() function in PHP.
There is a short alias: q(). Without second argument escape uses ENT_QUOTES as default and escapes both &lt;/&gt; and both single and double quotes:

<div class=grey_box><pre>
$T = new Blitz();
$T-&gt;load('{{ q($a); }}
{{ q($a, "ENT_COMPAT") }}
{{ q($a, "ENT_QUOTES") }}
{{ q($a, "ENT_NOQUOTES") }}
');

$T-&gt;display(array('a' =&gt; "here's a \"test\" &lt;&gt;\'\""));
</pre></div>

<div class=grey_box><pre>
here&amp;#039;s a &amp;quot;test&amp;quot; &amp;lt;&amp;gt;\&amp;#039;&amp;quot;
here's a &amp;quot;test&amp;quot; &amp;lt;&amp;gt;\'&amp;quot;
here&amp;#039;s a &amp;quot;test&amp;quot; &amp;lt;&amp;gt;\&amp;#039;&amp;quot;
here's a "test" &amp;lt;&amp;gt;\'"
</pre></div>

<br>

<a name="api-template-date"></a>
<h3>7.5 date(format [, arg)</h3>

Date() function formats a date. 
When "arg" is numerical, it is treated as UNIX timestamp integer. Otherwise it's parsed using internal PHP function "php_parse_date" which recognizes a lot of date formats. When "arg" is omitted - the current time is used. Format string has the same conversion specifiers as PHP function "strftime".<br><br>

Consider the following PHP code:
<div class=grey_box><pre>
$body = &lt;&lt;&lt;BODY
{{ date("%d %m %Y %H:%M:%S",\$time_num); }}
{{ date("%d %m %Y %H:%M:%S",\$time_str); }}

BODY;

$T = new Blitz();
$T->load($body);

$time_num = mktime(11, 22, 33, 7, 22, 1976);
$time_str = '1976-07-22 01:02:03';
$T->display(
    'time_num' => $time_num,
    'time_str' => $time_str
);
</pre></div>

This code outputs:
<div class=grey_box><pre>
22 07 1976 11:22:33
22 07 1976 01:02:03
</pre></div>

WARNING: Before 0.7.1.10 Blitz used internal PHP timelib library by default. This binding did't work properly. If you got something like "symbol lookup error: /path/lib/php/extensions/no-debug-non-zts-20090626/blitz.so: undefined symbol: timelib_time_ctor") - then the fastest way to fix this is either to get newest source or to recompile Blitz with changed line "#define BLITZ_WITH_TIMELIB 0". 

<br><br>

<a name="api-view"></a>

<h2>8. View API</h2>

<div class="notice">
<ul>
<li><a href="#api-view-load">load($body)</a> - load template body from variable
<li><a href="#api-view-set">set($vars)</a> - set iterations/variables
<li><a href="#api-view-parse">parse([$vars])</a> - set $vars and return rendered template as string
<li><a href="#api-view-display">display([$vars])</a> - set $vars and output rendered template as string
<li><a href="#api-view-block">block($path, $vars [, $iterate_nonexistant])</a> - iterate $path with $vars
<li><a href="#api-view-fetch">fetch($path, $vars)</a> - output context $path rendered as string with $vars
<li><a href="#api-view-include">include($filename, $vars)</a> - load template $filename and return rendered with $vars as string
<li><a href="#api-view-clean">clean()</a> - clean internal iteration data
<li><a href="#api-view-get-set-globals">getGlobals()</a> - return globals as hash 
<li><a href="#api-view-get-set-globals">setGlobals($global_vars)</a> - set globals 
<li><a href="#api-view-has-context">hasContext($path)</a> - check if context $path exists in the template
<li><a href="#api-view-context">context($path)</a> - set current context to $path
<li><a href="#api-view-iterate">iterate($path [, $iterate_nonexistant])</a> - create new $path iteration with empty data
<li><a href="#api-view-get-context">getContext()</a> - get current working context
<li><a href="#api-view-get-struct">getStruct()</a> - return template structure as an array of paths.
<li><a href="#api-view-dump-struct">dumpStruct()</a> - dump template structure in some internal 
<li><a href="#api-view-get-iterations">getIterations()</a> - get internal iteration data representing the current template state 
</ul>

<br>
<b>NOTE:</b> depending on your religious views you may use either <b>CamelCaps</b> or <b>under_bars</b> coding style. For any <b>doSomething</b> Blitz can <b>do_something</b> as well.

</div>

<br>

<h3>8.1. load($body)</h3>
<a name="api-view-load"></a>

Load() just loads template body from variable:
<div class=grey_box><pre>
$T = new blitz();
$T->load('Have a lot of {{ $what}}!');
$T->display(array('what' => 'fun'));
</pre></div>

<br>

<h3>8.2. set($vars)</h3>
<a name="api-view-set"></a>

Set variables or complex iteration data into the current context. Set accepts mixed $vars that represent internal iteration state: when it's array - it's interpreted as list.

<div class=grey_box><pre>
$T = new Blitz();
$T->load("{{ BEGIN characters }} {{ \$_num }}. {{ \$name }} {{ if(\$rip,'[R.I.P.]') }}\n{{ END characters}}");

$data = array(
    'characters' => array(
        array('name' => 'The Dude'),
        array('name' => 'Walter Sobchak'),
        array('name' => 'Donny', 'rip' => TRUE), // RIP, Donny
        array('name' => 'Maude Lebowski'),
        array('name' => 'The Big Lebowski'),
        array('name' => 'Brandt'),
        array('name' => 'Jesus Quintana'),
    )
);

$T->set($data);
$T->display();
</pre></div>

This code outputs:
<div class=grey_box><pre>
 1. The Dude
 2. Walter Sobchak
 3. Donny [R.I.P.]
 4. Maude Lebowski
 5. The Big Lebowski
 6. Brandt
 7. Jesus Quintana
</pre></div>

If you want to render the whole template several times - there should be an array at the most upper level:

<div class=grey_box><pre>
T = new Blitz();
$T->load("Hello {{ \$name }}!\n");
$T->set(
    array(
        0 => array('name' => 'dude'),
        1 => array('name' => 'world')
    )
);
$T->display();
</pre></div>

this code outputs:

<div class=grey_box><pre>
Hello dude!
Hello world!
</pre></div>

<br>

<h3>8.3. parse([$vars])</h3>
<a name="api-view-parse"></a>

Parse() method sets $vars and returns rendered template as string. Vars structure has the same semantics as for set(). 
You can just say "echo $T-&gt;parse($vars)" instead of $T-&gt;set($vars) and $T-&gt;display() in previous example.

<br><br>

<h3>8.4. display([$vars])</h3>
<a name="api-view-display"></a>

Display() method sets $vars and outputs rendered template. Vars structure has the same semantics as for set().
You can just say $T-&gt;display($vars) instead of $T-&gt;set($vars) and $T-&gt;display() in previous example.

<br><br>

<h3>8.5. block($path, $vars [, $iterate_nonexistant = FALSE])</h3>
<a name="api-view-block"></a>

Block() populates context $path with $vars. When $iterate_nonexistant is TRUE block() will not check
if this $path is valid (this may be useful for complex templates with includes).

main.tpl:
<div class=grey_box><pre>
{{ $question }}
{{ BEGIN answers }}
- {{ $text }}
{{ END}}
</pre></div>

php code:
<div class=grey_box><pre>
$T = new Blitz('ex3.tpl');
$T->display(
    array(
        'question' => 'Do I make myself clear, Lebowski?',
        'answers' => array(
            0 => array('text' => 'Yes'),
            1 => array('text' => 'No'),
            2 => array('text' => 'Sorry, I wasn\'t listening'),
        )
    )
);
</pre></div>

this code outputs:
<div class=grey_box><pre>
Do I make myself clear, Lebowski?
- Yes
- No
- Sorry, I wasn't listening
</pre></div>

<br>

<h3>8.6. fetch($path, $vars)</h3>
<a name="api-view-fetch"></a>
Fetch() method outputs context $path rendered with $vars. <a href="#basics-fetch">Example</a>

<br><br>

<h3>8.7. include($filename, $vars)</h3>
<a name="api-view-include"></a>

In some cases you need to include a template from your PHP-code.
This happens quite rarely and basically it's a bad style cause this increases template controller/code coupling,
but if you need to do this without creating Blitz instance - you can use include() method.

Consider this php code:
<div class=grey_box><pre>
class View extends Blitz {
    var $news = array();

    function View($tmpl_name) {
        return parent::Blitz($tmpl_name);   
    }
    
    function setNews($data) {
        $this->news = $data;
    }
    
    function showNewsList() {
        $result = '';
        foreach ($this->news as $i_news) {
            $result .= $this->include('news_list_item.tpl', $i_news);
        }
        return $result;
    }
}
</pre></div>

Here showNewsList() method gets the result of news_list_item.tpl template execution, passing news data into included template.

Blitz supports context iteration when you include template with contexts:

<div class=grey_box><pre>
$T = new Blitz();
$T->load('{{ include("include_ctx.tpl") }}');

$i = 0;
while ($i<5) {
    $T->block('/test1', array('var' => $i), TRUE);
    $T->block('/test2', array('var' => $i + 1), TRUE);
    $i++;
}

echo $T->parse();
</pre></div>

include_ctx.tpl:
<div class=grey_box><pre>
test1: {{ begin test1 }} v1={{ $var }} {{ end }}
test2: {{ begin test2 }} v2={{ $var }} {{ end }}
</pre></div>

output:
<div class=grey_box><pre>
test1:  v1=0  v1=1  v1=2  v1=3  v1=4 
test2:  v2=1  v2=2  v2=3  v2=4  v2=5
</pre></div>

Note that we used an additional 3rd parameter in block method. This parameter tells blitz to iterate /test1 and /test2 blocks without any check if corresponding context exists. Include is processed at the execution stage, that's why Blitz knows nothing about included templates structure when setting varibles or iterating contexts.

<br><br>

<h3>8.8. clean()</h3>
<a name="api-view-clean"></a>

Clean() method just cleans-up all template iterations and sets the template in the initial stage as if it was just created:

<div class=grey_box><pre>
$T = new Blitz();
$T->load('{{ IF question }}
{{ BEGIN question }}Who the fuck are the {{ $name }}? {{ END question }}
{{ ELSE }}
empty
{{ END }}');

$T->set(array('question' => array('name' => 'Knutsens')));
$T->display();

var_dump($T->getIterations());

$T->clean();
var_dump($T->getIterations());

$T->display();
</pre></div>

This code outputs:
<div class=grey_box><pre>
Who the fuck are the Knutsens?
array(1) {
  [0]=>
  array(1) {
    ["question"]=>
    array(1) {
      ["name"]=>
      string(8) "Knutsens"
    }
  }
}
array(0) {
}
empty
</pre></div>

<br>

<h3>8.9. setGlobals($global_vars), getGlobals()</h3>
<a name="api-view-get-set-globals"></a>
getGlobals() returns globals hash array, setGlobals($global_vars) - adds $global_vars to the global variables hash:

<div class=grey_box><pre>
$body = '
It\'s like what {{ $local }} said...
It\'s like what {{ $global }} said...
{{ BEGIN context }}
    It\'s like what {{ $local }} said...
    It\'s like what {{ $global }} said...
{{ END context }}
';

$T = new Blitz();
$T->load($body);
$T->set(array('local' => 'Lennon'));
$T->setGlobals(array('global' => 'Lenin'));
$T->block('context', array('local' => 'Lenin'));
$T->display();
var_dump($T->getGlobals());
var_dump($T->getIterations());
</pre></div>

This code outputs:
<div class=grey_box><pre>
It's like what Lennon said...
It's like what Lenin said...
    It's like what Lenin said...
    It's like what Lenin said...
array(1) {
  ["global"]=>
  string(5) "Lenin"
}
array(1) {
  [0]=>
  array(2) {
    ["local"]=>
    string(6) "Lennon"
    ["context"]=>
    array(1) {
      [0]=>
      array(1) {
        ["local"]=>
        string(5) "Lenin"
      }
    }
  }
}
</pre></div>

<br>Please remember that usually you don't need to pass local variables to every block - you can just use <a href="#basics-scope">"scope lookups"</a> with blitz.scope_lookup_limit and varibles from parent blocks will be visible in inner blocks. Here $local is passed to "/context" just because we needed this variable to have different values in the root "/" and "/context".

<br><br>

<h3>8.12. hasContext($path)</h3>
<a name="api-view-has-context"></a>

This method just checks if the context exists or not and returns TRUE/FALSE correspondingly.

<div class=grey_box><pre>
$body = '{{ BEGIN walter }} I don\'t roll on Shabbos {{ END }}';

$T = new Blitz();
$T->load($body);

var_dump($T->hasContext('walter'));
var_dump($T->hasContext('donny'));
</pre></div>

This code outputs:
<div class=grey_box><pre>
bool(true)
bool(false)
</pre></div>

<br>

<h3>8.13. context($path)</h3>
<a name="api-view-context"></a>

<br>

<h3>8.14. iterate($path [, $iterate_nonexistant])</h3>
<a name="api-view-iterate"></a>

<h3>8.15. getContext()</h3>
<a name="api-view-get-context"></a>

<br>

<h3>8.16. getStruct()</h3>
<a name="api-view-get-struct"></a>
getStruct() - returns template structure as an array of available paths.

<br>

<h3>8.17. dumpStruct()</h3>
<a name="api-view-dump-struct"></a>

<h3>8.18. getIterations()</h3>
<a name="api-view-get-iterations"></a>
getIterations() - get internal iteration data representing the current template state. <a href="#example-get-iterations">Example</a>

</body>
</html>
